package gin

import (
	"bytes"
	"fmt"
	pb "github.com/lightbrotherV/gin-protobuf/protoc-gen-lightbrother/descriptor"
	"github.com/lightbrotherV/gin-protobuf/protoc-gen-lightbrother/generator"
	plugin_go "github.com/lightbrotherV/gin-protobuf/protoc-gen-lightbrother/plugin"
	"path"
	"path/filepath"
	"strconv"
	"strings"
)

const (
	ginPkgPath     = "github.com/gin-gonic/gin"
	contextPkgPath = "context"
	httpPkgPath    = "net/http"
)

func init() {
	generator.RegisterPlugin(new(gin))
}

type gin struct {
	gen                 *generator.Generator
	serviceMethodRoutes map[string]string
	*bytes.Buffer
	methodMiddleware map[string][]string // 每个方法拥有的中间件
	hasInput         map[string]bool     // 方法是否有输入
	hasOutput        map[string]bool     // 方法是否有输出
	httpMethod       map[string]string   // http的请求方法
	middlewarePool   []string            // 中间件池
	filename         string
}

func (g *gin) Name() string {
	return "gin"
}

func (g *gin) Init(gen *generator.Generator) {
	g.gen = gen
	g.Buffer = new(bytes.Buffer)
	g.serviceMethodRoutes = make(map[string]string)
	g.methodMiddleware = make(map[string][]string)
	g.hasInput = make(map[string]bool)
	g.hasOutput = make(map[string]bool)
	g.httpMethod = make(map[string]string)
}

func (g *gin) Generate(file *generator.FileDescriptor) {
	if len(file.GetService()) == 0 {
		return
	}
	g.Reset()
	fileName := filepath.Base(file.GetName())
	g.filename = strings.ReplaceAll(fileName, filepath.Ext(fileName), "")
	name := getFileName(file.GetName())
	g.generateHeader(file)
	//json, _ := json.Marshal(file)
	//content := fmt.Sprint(string(json))
	g.generateServiceRoute(file)
	g.generateService(file)
	g.generateHelperFunc()
	g.genterateMiddleware()
	//提取生成的代码
	content := g.String()
	ginFile := &plugin_go.CodeGeneratorResponse_File{
		Name:    &name,
		Content: &content,
	}
	resFile := g.gen.Response.File
	resFile = append(resFile, ginFile)
	g.gen.Response.File = resFile
}

func (g *gin) GenerateImports(file *generator.FileDescriptor) {

}

func (g *gin) generateHeader(file *generator.FileDescriptor) {
	goPackageName := string(file.PackageName)
	g.P("// Code generated by protoc-gen-lightbrother, DO NOT EDIT.")
	g.P()
	g.P("/*")
	g.P(fmt.Sprintf("Package %s is a generated gin stub package.", goPackageName))
	g.P("This code was generated with protoc-gen-lightbrother. ")
	g.P()
	g.P("It is generated from these files:")
	g.P(fmt.Sprintf("\t%s", file.GetName()))
	g.P("*/")
	g.P(fmt.Sprintf("package %s", goPackageName))
	g.P()
	g.P("import (")
	g.P(fmt.Sprintf("\t%s", strconv.Quote(ginPkgPath)))
	g.P(fmt.Sprintf("\t%s", strconv.Quote(contextPkgPath)))
	g.P(fmt.Sprintf("\t%s", strconv.Quote(httpPkgPath)))
	g.P(")")
	g.P()
	g.P("// to suppressed 'imported but not used warning'")
	g.P()
	g.P(fmt.Sprintf("const %s_HTTP_METGOD = \"GRPC\"", strings.ToUpper(g.filename)))
	g.P()
}

func (g *gin) generateService(file *generator.FileDescriptor) {
	services := file.GetService()
	packageName := file.PackageName
	for i, serv := range services {
		servName := generator.CamelCase(serv.GetName())
		servCommentsPath := fmt.Sprintf("6,%d", i)
		g.P(fmt.Sprintf("// %sGinServer is the server API for %s service.", servName, servName))
		comments := file.Comments[servCommentsPath].GetLeadingComments()
		g.printComments(comments, "")
		g.setServiceMethodComment(serv.GetName(), comments)
		g.P(fmt.Sprintf("type %sGinServer interface {", servName))
		g.generateInterfaceProperties(file, serv, i)
		g.P("}")
		g.P()
		g.P(fmt.Sprintf("var %s%sSvc %sGinServer", packageName, servName, servName))
		g.P()
		g.generateHandleFunc(file, serv)
		g.generateRegister(file, serv)
	}
}

func (g *gin) generateServiceRoute(file *generator.FileDescriptor) {
	packageName := file.GetPackage()
	services := file.GetService()
	for _, serv := range services {
		originServName := serv.GetName()
		for _, method := range serv.Method {
			g.P(fmt.Sprintf("var %s = \"/%s.%s/%s\"", g.getRouteVariable(serv, method), packageName, originServName, method.GetName()))
		}
	}
	g.P()
}

func (g *gin) generateInterfaceProperties(file *generator.FileDescriptor, service *pb.ServiceDescriptorProto, index int) {
	methods := service.GetMethod()
	serviceName := service.GetName()
	servicesLen := len(methods)
	for i, method := range methods {
		methodCommentsPath := fmt.Sprintf("6,%d,2,%d", index, i)
		comments := file.Comments[methodCommentsPath].GetLeadingComments()
		g.printComments(comments, "\t")
		g.setServiceMethodComment(g.getMethodServiceKey(serviceName, method.GetName()), comments)
		methodName := generator.CamelCase(method.GetName())
		g.P(fmt.Sprintf("\t%s(ctx context.Context, req *%s) (resp *%s, err error)", methodName, g.gen.TypeName(g.objectNamed(method.GetInputType())), g.gen.TypeName(g.objectNamed(method.GetOutputType()))))
		if i != servicesLen-1 {
			g.P()
		}
	}
}

func (g *gin) generateHandleFunc(file *generator.FileDescriptor, service *pb.ServiceDescriptorProto) {
	methods := service.GetMethod()
	packageName := file.PackageName
	servName := generator.CamelCase(service.GetName())
	for _, method := range methods {
		g.P(fmt.Sprintf("func %s(c *gin.Context) {", method.GetName()))
		g.P(fmt.Sprintf("\tp := new(%s)", g.gen.TypeName(g.objectNamed(method.GetInputType()))))
		if g.getServiceHasInput(service.GetName(), method.GetName()) {
			g.P("\tif err := c.BindJSON(p); err != nil {")
			g.P("\t\tc.Set(\"code\", -500)")
			g.P("\t\tc.Set(\"message\", err.Error())")
			g.P(fmt.Sprintf("\t\tc.JSON(http.StatusOK, get%sResponse(c, nil))", strings.Title(g.filename)))
			g.P("\t\treturn")
			g.P("\t}")
		}
		if g.getServiceHasOutput(service.GetName(), method.GetName()) {
			g.P(fmt.Sprintf("\tresp, err := %s%sSvc.%s(c, p)", packageName, servName, generator.CamelCase(method.GetName())))
			g.P("\tif err != nil {")
			g.P("\t\tc.Set(\"code\", -500)")
			g.P("\t\tc.Set(\"message\", err.Error())")
			g.P(fmt.Sprintf("\t\tc.JSON(http.StatusOK, get%sResponse(c, nil))", strings.Title(g.filename)))
			g.P("\t\treturn")
			g.P("\t}")
			g.P(fmt.Sprintf("\tc.JSON(http.StatusOK, get%sResponse(c, resp))", strings.Title(g.filename)))
		} else {
			g.P(fmt.Sprintf("\t%s%sSvc.%s(c, p)", packageName, servName, generator.CamelCase(method.GetName())))
		}
		g.P("}")
		g.P()
	}
}

func (g *gin) generateRegister(file *generator.FileDescriptor, service *pb.ServiceDescriptorProto) {
	originServiceName := service.GetName()
	servName := generator.CamelCase(originServiceName)
	methods := service.GetMethod()
	packageName := file.PackageName
	g.P(fmt.Sprintf("func Register%s%sGinServer(e *gin.Engine, server %sGinServer) {", generator.CamelCase(g.filename), servName, servName))
	g.P(fmt.Sprintf("\t%s%sSvc = server", packageName, servName))
	for _, method := range methods {
		methodMiddleware := g.getMethodMiddleware(service, method)
		httpMethod := g.getServiceHttpMethod(originServiceName, method.GetName())
		if methodMiddleware != "" {
			g.P(fmt.Sprintf("\te.Handle(%s, %s, %s, %s)", httpMethod, g.getRouteVariable(service, method), methodMiddleware, method.GetName()))
		} else {
			g.P(fmt.Sprintf("\te.Handle(%s, %s, %s)", httpMethod, g.getRouteVariable(service, method), method.GetName()))
		}
	}
	g.P("}")
	g.P()
}

// 获取路由变量名
func (g *gin) getRouteVariable(serv *pb.ServiceDescriptorProto, method *pb.MethodDescriptorProto) string {
	servName := generator.CamelCase(serv.GetName())
	methodName := generator.CamelCase(method.GetName())
	return fmt.Sprintf("Path%s%s", servName, methodName)
}

// 写入缓冲区
func (g *gin) P(str ...interface{}) {
	for _, v := range str {
		g.printAtom(v)
	}
	g.WriteByte('\n')
}

// 打印注释
func (g *gin) printComments(comment string, pre string) {
	comments := generator.GetCommentWithoutTag(comment)
	for _, line := range comments {
		g.P(fmt.Sprintf("%s//%s", pre, line))
	}
}

// printAtom prints the (atomic, non-annotation) argument to the generated output.
func (g *gin) printAtom(v interface{}) {
	switch v := v.(type) {
	case string:
		g.WriteString(v)
	case *string:
		g.WriteString(*v)
	case bool:
		fmt.Fprint(g, v)
	case *bool:
		fmt.Fprint(g, *v)
	case int:
		fmt.Fprint(g, v)
	case *int32:
		fmt.Fprint(g, *v)
	case *int64:
		fmt.Fprint(g, *v)
	case float64:
		fmt.Fprint(g, v)
	case *float64:
		fmt.Fprint(g, *v)
	case generator.GoPackageName:
		g.WriteString(string(v))
	case generator.GoImportPath:
		g.WriteString(strconv.Quote(string(v)))
	}
}

// 获取文件名称
func getFileName(name string) string {
	if ext := path.Ext(name); ext == ".proto" || ext == ".protodevel" {
		name = name[:len(name)-len(ext)]
	}
	name += ".gin.go"
	return name
}

// Given a type name defined in a .proto, return its object.
// Also record that we're using it, to guarantee the associated import.
func (g *gin) objectNamed(name string) generator.Object {
	return g.gen.ObjectNamed(name)
}

// 从注释中提取记录服务各类参数
func (g *gin) setServiceMethodComment(serviceName, comments string) {
	tags := generator.GetTagsInComment(comments)
	// 中间件
	middlewareStr := generator.GetTagValue("middleware", tags)
	middlewareArr := strings.Split(middlewareStr, ",")
	for _, middleware := range middlewareArr {
		if middleware == "" {
			continue
		}
		// 加入中间件池
		g.middlewarePool = append(g.middlewarePool, middleware)

		// 加入对应的方法
		g.methodMiddleware[serviceName] = append(g.methodMiddleware[serviceName], middleware)
	}

	// 是否有输入
	hasInput := generator.GetTagValue("hasInput", tags)
	if hasInput == "true" || hasInput == "" {
		g.hasInput[serviceName] = true
	} else {
		g.hasInput[serviceName] = false
	}

	// 是否有输出
	hasOutput := generator.GetTagValue("hasOutput", tags)
	if hasOutput == "true" || hasOutput == "" {
		g.hasOutput[serviceName] = true
	} else {
		g.hasOutput[serviceName] = false
	}

	// 请求方法
	httpMethod := generator.GetTagValue("method", tags)
	if httpMethod != "" {
		g.httpMethod[serviceName] = httpMethod
	}
}

func (g *gin) generateHelperFunc() {
	g.P("// 返回数据格式化")
	g.P(fmt.Sprintf("func get%sResponse(c *gin.Context, data interface{}) gin.H {", strings.Title(g.filename)))
	g.P("\tresponseData := make(map[string]interface{})")
	g.P("\tcode, ok := c.Get(\"code\")")
	g.P("\tif !ok {")
	g.P("\t\tcode = 0")
	g.P("\t}")
	g.P("\tmsg, ok := c.Get(\"message\")")
	g.P("\tif !ok {")
	g.P("\t\tmsg = \"\"")
	g.P("\t}")
	g.P("\tresponseData[\"code\"] = code")
	g.P("\tresponseData[\"message\"] = msg")
	g.P("\tresponseData[\"data\"] = data")
	g.P("\treturn responseData")
	g.P("}")
	g.P()
}

// 中间件
func (g *gin) genterateMiddleware() {
	if len(g.middlewarePool) > 0 {

		// 去除重复的
		g.middlewarePool = RemoveRepeatedElement(g.middlewarePool)

		// 变量
		g.P("var (")
		for _, middlewareStr := range g.middlewarePool {
			funcName := fmt.Sprintf("%s%sMiddleware", g.filename, generator.CamelCase(middlewareStr))
			g.P(fmt.Sprintf("\t%s []gin.HandlerFunc", funcName))

		}
		g.P(")")
		g.P()

		// 对外暴露注册函数
		for _, middlewareStr := range g.middlewarePool {
			funcName := fmt.Sprintf("%s%sMiddleware", g.filename, generator.CamelCase(middlewareStr))
			g.P(fmt.Sprintf("func Register%s(f gin.HandlerFunc) {", strings.Title(funcName)))
			g.P(fmt.Sprintf("\t%s = append(%s, f)", funcName, funcName))
			g.P("}")
			g.P()
		}

		// 调用注册的函数
		for _, middlewareStr := range g.middlewarePool {
			g.P(fmt.Sprintf("func handle%s%sMiddleware(c *gin.Context) {", generator.CamelCase(g.filename), strings.Title(middlewareStr)))
			funcName := fmt.Sprintf("%s%sMiddleware", g.filename, generator.CamelCase(middlewareStr))
			g.P(fmt.Sprintf("\tfor _, middleware := range %s {", funcName))
			g.P("\t\tif c.IsAborted() {")
			g.P("\t\t\tbreak")
			g.P("\t\t}")
			g.P("\t\tmiddleware(c)")
			g.P("\t}")
			g.P("}")
			g.P()
		}

	}
}

func (g *gin) getMethodMiddleware(serv *pb.ServiceDescriptorProto, method *pb.MethodDescriptorProto) string {
	servName := serv.GetName()
	methodName := method.GetName()
	methodMiddlewareArr := make([]string, 0)
	methodServiceMiddlewareArr, ok := g.methodMiddleware[servName]
	setArr := make([]string, 0)
	result := make([]string, 0)
	if ok {
		for _, methodServiceMiddleware := range methodServiceMiddlewareArr {
			setArr = append(setArr, methodServiceMiddleware)
		}
	}

	methodMiddlewareKey := g.getMethodServiceKey(servName, methodName)

	methodMiddlewareArr, ok = g.methodMiddleware[methodMiddlewareKey]
	if ok {
		for _, methodMiddleware := range methodMiddlewareArr {
			setArr = append(setArr, methodMiddleware)
		}
	}

	setArr = RemoveRepeatedElement(setArr)

	for _, methodMiddleware := range setArr {
		result = append(result, fmt.Sprintf("handle%s%sMiddleware", generator.CamelCase(g.filename), strings.Title(methodMiddleware)))
	}

	return strings.Join(result, ", ")
}

func (g *gin) getMethodServiceKey(servName, methodName string) string {
	return fmt.Sprintf("%s:%s", servName, methodName)
}

// 获取rpc的http请求方法
func (g *gin) getServiceHttpMethod(servName, methodName string) string {
	if mn := g.httpMethod[g.getMethodServiceKey(servName, methodName)]; mn != "" {
		return "\"" + mn + "\""
	}

	if mn := g.httpMethod[servName]; mn != "" {
		return "\"" + mn + "\""
	}

	return fmt.Sprintf("%s_HTTP_METGOD", strings.ToUpper(g.filename))
}

// 获取rpc服务是否有输入
func (g *gin) getServiceHasInput(servName, methodName string) bool {
	if !g.hasInput[g.getMethodServiceKey(servName, methodName)] || !g.hasInput[servName] {
		return false
	}
	return true
}

// 获取rpc服务是否有输出
func (g *gin) getServiceHasOutput(servName, methodName string) bool {
	if !g.hasOutput[g.getMethodServiceKey(servName, methodName)] || !g.hasOutput[servName] {
		return false
	}
	return true
}

// 稳定去除数组内相同的元素（set化）
func RemoveRepeatedElement(arr []string) []string {
	noRepeatArr := make([]string, 0)
	reverseArr := make([]string, 0)
	noRepeatReverseArr := make([]string, 0)
	arrLen := len(arr)
	for i := arrLen - 1; i >= 0; i-- {
		reverseArr = append(reverseArr, arr[i])
	}
	for i := 0; i < len(reverseArr); i++ {
		repeat := false
		for j := i + 1; j < len(reverseArr); j++ {
			if reverseArr[i] == reverseArr[j] {
				repeat = true
				break
			}
		}
		if !repeat {
			noRepeatArr = append(noRepeatArr, reverseArr[i])
		}
	}
	reverseArrLen := len(noRepeatArr)
	for i := reverseArrLen - 1; i >= 0; i-- {
		noRepeatReverseArr = append(noRepeatReverseArr, noRepeatArr[i])
	}
	return noRepeatReverseArr
}
